[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this Blog",
    "section": "",
    "text": "Hello üëã Welcome to my blog!!! This is a collection of things-I-want-to-understand-better. The world is full of complex and interesting ideas. Often these ideas come in many layers (like ogres). I think the best way to unpack these ideas is to be forced to explain it to someone - in doing so peel back those layers. This blog keeps me accountable and motivated through that process.\nWho am I?\n24601 üéµ\nJust kidding‚Ä¶ I currently do a bit of Cloud Engineering to earn my keep. I‚Äôm still quite fresh to this field, having come from more of a Data Science & Data Engineering background. My training was in physics - an area which I feel as if I have barely scratched the surface of and am keen to explore more."
  },
  {
    "objectID": "posts/sum-fun/index.html",
    "href": "posts/sum-fun/index.html",
    "title": "Having Sum Fun",
    "section": "",
    "text": "The concept of reducibility has always fascinated me - the fact that you can take an unbelieveably complex thing and elegantly express it a single thing that can fit on the margins of a page. An interesting example of this is the Riemann Zeta function."
  },
  {
    "objectID": "posts/sum-fun/index.html#part-i-s-1-the-triangular-numbers",
    "href": "posts/sum-fun/index.html#part-i-s-1-the-triangular-numbers",
    "title": "Having Sum Fun",
    "section": "1.1 Part I: \\(s=-1\\): The Triangular Numbers",
    "text": "1.1 Part I: \\(s=-1\\): The Triangular Numbers\nFor \\(s=-1\\): \\[\n\\zeta(-1) = 1 + 2 + 3 + 4 + \\dots\n\\] We already know this series will diverge, so that‚Äôs boring. Let‚Äôs think about something less trivial. Rather than add numbers up forever, we only add up to the number \\(N\\). We call this a partial sum 1: \\[\n\\zeta_N(-1) = \\sum_{n=1}^N \\frac{1}{n^{(-1)}}=1+2+3+\\dots + N\n\\] Obviously we can calculate this by simply adding every number up until \\(N\\), but can we find a shortcut to do this computation? Let‚Äôs try get some intuition by writing down the first few values of \\(N\\):\n\n\n\n\\(N\\)\n\\(\\zeta_N(-1)\\)\n\n\n\n\n1\n1\n\n\n2\n3\n\n\n3\n6\n\n\n4\n10\n\n\n\nIt may not be obvious, but there is a pattern here. The result is what‚Äôs called the ‚ÄúTriangular Numbers‚Äù (\\(T_N\\)). The namesake is clear from the following diagram:\n\n\n\n\n\n\nFigure¬†1: Triangular Numbers (By Melchoir - Own work, CC BY-SA 3.0, Link)\n\n\n\nHow do we figure out the formula for \\(T_N\\)? We do this by making a rectangle with dimension \\(N \\times (N+1)\\), and then noting that the triangular numbers are always half of this rectangle.\nFor \\(N=2\\), we make a \\(2\\times3=6\\) rectangle, and note that \\(T_2 =3\\).\nFor \\(N=3\\), we make a \\(3\\times4=12\\) rectangle, and note that \\(T_3 = 6\\).\nFor \\(N=4\\), we make a \\(4\\times 5 = 20\\) rectangle, and note that \\(T_4=10\\).\nSo we propose a formula: \\[\nT_N = \\zeta_N (-1) = \\frac{N(N+1)}{2}\n\\] We have shown this is true for the first few values of \\(N\\), but how do we know this is always true? We can prove this by induction.\nFor the base case of \\(N=1\\), we know that \\(T_1=1\\).\nLet‚Äôs assume the formula is true for the case \\(T_k\\), so we have: \\[\nT_k = \\frac{k(k+1)}{2}\n\\] What about \\(T_{k+1}\\)? Well let‚Äôs see what we get when we add \\(k+1\\) to the above: \\[\n\\begin{align*}\nT_{k+1} &= \\frac{k(k+1)}{2} + (k+1) \\\\\n&= \\frac{k(k+1)+2(k+1)}{2} \\\\\n&= \\frac{(k+1)(k+2)}{2} \\\\  \n&= \\frac{(k+1)((k+1)+1)}{2}\n\\end{align*}\n\\] We never assumed the formula was true for \\(T_{k+1}\\), but we stumbled on the formula for that case by just taking \\(T_{k}\\) and adding \\(k+1\\) to it! Since I never specified what \\(k\\) was, we know this logic is true for any \\(k \\in \\mathbb{N}\\). If \\(k=1\\), then we know the formula holds true for \\(k=2\\). If we know the formala holds true for \\(k=2\\), it must also hold true for \\(k=3\\). So we have proven this fomula is true in general \\(\\forall k \\in \\mathbb{N}\\) how neat is that!\nThis means we don‚Äôt need to keep adding terms to compute \\(T_N\\). We just need to apply the formula! For example: \\[\nT_{1000} = \\frac{1000(1000+1)}{2} = 500500\n\\]"
  },
  {
    "objectID": "posts/sum-fun/index.html#part-ii-s1-the-harmonic-series",
    "href": "posts/sum-fun/index.html#part-ii-s1-the-harmonic-series",
    "title": "Having Sum Fun",
    "section": "1.2 Part II: \\(s=1\\): The Harmonic Series",
    "text": "1.2 Part II: \\(s=1\\): The Harmonic Series\nFor \\(s=1\\): \\[\n\\zeta(1) = 1 +\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + ...\n\\] This is called the ‚ÄúHarmonic Series‚Äù because it represents the wavelengths of harmonics in music. If the fundamental wavelength is \\(1\\), then the wavelength of the next harmonic is half, then the next is a third and so on.\nWe can see each term in our sum getting smaller and smaller. But does it get small enough fast enough? Let‚Äôs have a look:\n\n\n\n\n\n\n\n\nFigure¬†2: First N=1000 values of the harmonic series partial sum.\n\n\n\n\n\nIt looks like it‚Äôs flattening out to some finite value‚Ä¶ but looks can be deceiving. This series actually diverges! It diverges really really slowly, but nonetheless it diverges. Let‚Äôs prove that shall we? Ignoring the first two terms, let‚Äôs start by grouping by \\(2^n\\). That is, twos, fours, eights etc. \\[\n\\zeta(1) = 1 + \\frac{1}{2} + \\left( \\frac{1}{3} +  \\frac{1}{4} \\right) + \\left( \\frac{1}{5} + \\frac{1}{6} + \\frac{1}{7} + \\frac{1}{8} \\right) + ...\n\\] We notice something intriguing. Each group is slightly bigger than half.\nFor our first parenthesis: \\[\n\\left( \\frac{1}{3} +  \\frac{1}{4} \\right) &gt; \\left( \\frac{1}{4} +  \\frac{1}{4} \\right) = \\frac{1}{2}\n\\] For our second parenthesis: \\[\n\\left( \\frac{1}{5} + \\frac{1}{6} + \\frac{1}{7} + \\frac{1}{8} \\right) &gt; \\left( \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} \\right) = \\frac{1}{2}\n\\] If we put this together: \\[\n\\zeta(1) &gt; 1 + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + ... \\to \\infty \\quad \\therefore \\quad \\zeta(1) \\to \\infty\n\\]\n\nThe sum of adding \\(\\frac{1}{2}\\) is smaller than the Harmonic series.\nIf you add the same number over and over again forever, your sum will diverge.\nSince a smaller series diverges, the bigger series (ie. Harmonic Series) has to diverges.\n\nCongratulations, you just used the creatively named comparison test to prove the Harmonic Series diverges ü•≥ But it turns out this is the limit! Any smaller and your series will converge! So \\(\\zeta(s)\\) is actually finite for \\(s&gt;1\\)."
  },
  {
    "objectID": "posts/sum-fun/index.html#part-iii-s2-the-basel-problem",
    "href": "posts/sum-fun/index.html#part-iii-s2-the-basel-problem",
    "title": "Having Sum Fun",
    "section": "1.3 Part III: \\(s=2\\): The Basel Problem",
    "text": "1.3 Part III: \\(s=2\\): The Basel Problem\nFor \\(s=2\\): \\[\n\\zeta(2) = 1 +\\frac{1}{4} + \\frac{1}{9} + \\frac{1}{16} + ...\n\\] I mentioned (without proof), we expect this to converge. But what does it converge to? This is historically called the ‚ÄúBasel 2 Problem‚Äù which none other than the famous Lenoard Euler himself solved.\nThis proof is quite beautiful and takes us on a scenic route by expanding \\(g(x)=\\frac{\\sin(x)}{x}\\). We will expand this function in two different ways and then when we put it together, \\(\\zeta(2)\\) magically falls out ü™Ñ\n\n1.3.1 ‚ûï Taylor Expansion\nThe Taylor expansion gives us a way to approximate any function3, by taking an infinite SUM of polynomials. The Taylor expansion of the function \\(f(x)\\) around the point \\(x=0\\) is: \\[\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(0)}{n!}x^n = f(0) + f'(0)x + \\frac{f''(0)}{2} x^2 + \\dots\n\\]\nIf we take a Talyor expansion of \\(g(x)\\): \\[\n\\begin{align*}\n\\sin(x) &= x - \\frac{x^3}{3!} + \\frac{x^5}{5!} + \\dots \\\\\ng(x) = \\frac{\\sin(x)}{x} &= 1 - \\frac{x^2}{3!} + \\frac{x^4}{5!} + \\dots\n\\end{align*}\n\\]\nWe‚Äôll come back to this.\n\n\n1.3.2 ‚úñÔ∏è Polynomial Expansion\nIf we take a polynomial (even if it‚Äôs a infinite one), we can re-express that as an infinite PRODUCT of all its roots. This is called the Fundamental Theorem of Algebra4. Now we know when \\(\\sin(x)=0\\) then \\(x=\\pm\\pi, \\pm 2\\pi, \\dots\\), so: \\[\n\\begin{align*}\n\\sin(x) &= \\left(x-\\pi\\right)\\left(x+\\pi\\right)\\left(x-2\\pi\\right)\\left(x+2\\pi\\right) \\dots \\\\\ng(x) = \\frac{\\sin(x)}{x} &= \\left(1-\\frac{x}{\\pi}\\right)\\left(1+\\frac{x}{\\pi}\\right)\\left(1-\\frac{x}{2\\pi}\\right)\\left(1+\\frac{x}{2\\pi}\\right) \\dots\n\\end{align*}\n\\] Let‚Äôs collect all the \\(x^2\\) terms. How do we go about doing this? Here are a few points of intuition:\n\nWhen expanding the sum, we need to take either the left (\\(1\\)) or the right (\\(-\\frac{x}{\\pi}\\)) term.\nFor any \\(x^2\\) terms, you must take 2 right terms and the rest left.\nSince this is a symmetric function, any choice of the 2 right terms that don‚Äôt match (eg. \\(-\\frac{x}{\\pi}\\) and \\(-\\frac{x}{2\\pi}\\)) will have a counterpart and cancel out.\nThe only terms remaining is if the 2 right terms DO match.\n\nUsing this intuition, our sum simplifies to : \\[\n\\begin{align*}\ng(x) = 1 - \\left(\\frac{1}{\\pi^2} + \\frac{1}{4\\pi^2} + \\frac{1}{9\\pi^2} + \\dots \\right)x^2 + \\dots\n\\end{align*}\n\\]\nOooo do you see that? Does that look familiar? We‚Äôre almost there üí™\n\n\n1.3.3 ‚ú® Putting this together\nIf we match the \\(x^2\\) term from our two methods we get: \\[\n\\begin{align*}\n-\\left( \\frac{1}{\\pi^2} + \\frac{1}{4\\pi^2} + \\frac{1}{9\\pi^2} + \\dots \\right) &= -\\frac{1}{3!} \\\\\n\\left( 1 + \\frac{1}{4} + \\frac{1}{9} + \\dots \\right) \\frac{1}{\\pi^2} &= \\frac{1}{3!}  \\\\\n1 + \\frac{1}{4} + \\frac{1}{9} + \\dots  &= -\\frac{\\pi^2}{6}\n\\end{align*}\n\\]\nBut wait, the left handside is exactly \\(s=2\\) case! So we have basically proved: \\[\n\\zeta(2) = \\frac{\\pi}{6}\n\\]\nWhat just happened? By relating the Taylor expansion of \\(\\frac{\\sin(x)}{x}\\) with its roots, we have found \\(\\zeta(2)\\) embedded in the coefficients. Moreover, we just related the mathematics of infinite series (analysis) with the mathematics of circles (geometry) where the \\(\\pi\\) comes from. Isn‚Äôt that just so COOL? Being able to find a connection in an unlikely place.\nIt turns out that for cases where \\(s\\) is a positive even integer, a generalised method can be used to find the formula for those case."
  },
  {
    "objectID": "posts/sum-fun/index.html#footnotes",
    "href": "posts/sum-fun/index.html#footnotes",
    "title": "Having Sum Fun",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere a sum is typically assumed to be infinitely long unless otherwise stated.‚Ü©Ô∏é\nPresumably named after Basel, Switzerland where the problem was posed.‚Ü©Ô∏é\nAssuming it‚Äôs well-behaved enough‚Ä¶ I‚Äôm looking at you Weierstrass. It basically needs to be differentiable.‚Ü©Ô∏é\nI mean kind of, it‚Äôs more of a corollary to this but close enough.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/first-shiny-app/fuel_calc_app.html",
    "href": "posts/first-shiny-app/fuel_calc_app.html",
    "title": "üß™ Fuel Calculator App",
    "section": "",
    "text": "Demo App\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 1000\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\n\n# dist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\ndist_heuristics = pd.read_csv(open_url('https://raw.githubusercontent.com/bbpi2/bsf-leaders-retreat-2025/refs/heads/main/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\ndef dist_to_str(dist):\n  return str(round(dist, 2)) + \" km\"\n\ndef cost_to_str(cost):\n  return \"$\" + str(round(cost,2))\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Melbourne Central Station\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),\n    ),  \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n      ui.input_numeric(\"length\", \"How long is your drive in km (one way)?\", 0),\n      ui.input_slider(\"n_pax_d\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True),\n      ui.input_task_button(\"search_d\", \"Search\"),\n      ui.output_table(\"table_output_d\")\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      # pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = dist_to_str(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = dist_to_str(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = cost_to_str(cost_ppax) #\"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance (one way)\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance (one way)\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    @output\n    @render.table\n    @reactive.event(input.search_d)\n    def table_output_d():\n      n_pax = input.n_pax()\n      length = input.length()\n      cost_ppax = length * 0.1*2.5/n_pax\n\n      output = []\n      output.append({\"Item\": \"Distance (one way)\", \"Value\": dist_to_str(length)})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_to_str(cost_ppax)})\n      return pd.DataFrame(output)\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/first-shiny-app/index.html",
    "href": "posts/first-shiny-app/index.html",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "As I was planning a road trip with friends, I wondered if there was an easy way to estimate the fuel cost for each individual. Nothing out there seemed to meet the usecase I had, so I decided to build a webapp. What I thought was a quick and easy solution ended up taking ~20hr to develop, but given this was more about pedegogy than perfection, it was time well-spent.\nI began with three important considerations:\n\nüñ•Ô∏è Serverless - I don‚Äôt want to spin up a server just for this - it needs to be hostable on github.\nüí∞ Free - I don‚Äôt want to pay for anything, even if I‚Äôm adding a credit card to access a ‚Äúfree tier‚Äù.\nüö¢ Simple - I don‚Äôt want to spend time on something that won‚Äôt be shipped.\n\n\n\nOkay, so at the core of it, I needed an app that took in the following inputs:\n\nSource Location - where is the user coming from?\nNumber of Pax - how many people do we split the cost over?\n\nThe destination location is fixed for simplicity since we were all going to the same place for the trip. This will save us some complexity as we will soon see.\nAfter the user clicks ‚Äòsubmit‚Äô, I want to compute & display:\n\nDistance Travelled - there is a degree of ambiguity to this as we will soon see.\nCost per Pax - this is the target metric to calculate.\nA map - maps are fun üó∫Ô∏è\n\n\n\nSince this is my first webapp, I am not even sure of the infrastructure needed to build this solution. To make sure the project is feasible, I begin with a cut-down version of the requirements. Suppose the user already provides the Distance Travelled (say with a Google Maps search), let‚Äôs see if we can calculate the target metric of Cost per Pax.\nLet \\(C\\) be the cost per pax measure we want to calculate. Let:\n\n\\(\\epsilon\\) be the fuel efficiency. For this we used 0.1 L/km according to carsguide for a typical SUV.\n\\(\\varphi\\) be the fuel cost per litre. For this we take the estimate of $2.5.\n\\(D\\) be the distance travelled in km.\n\\(n\\) be the number of pax.\n\n\\[\nC = \\frac{\\epsilon\\varphi D}{n} = \\frac{0.25D}{n}\n\\]\n\n\n\nIn the final product, we want to go one step further and find a way to map between the Source Location and the Distance Travelled. The generic steps are:\n\nUser provides the source location in text string.\nThis text is mapped to a lattitude and longitude.\nThe distance between this source location and the destination location is calculated.\n\n\n\n\n\nThere is some ambiguity in the definition of Distance Travelled.\n\nFor the MVP case, this parameter is provided a priori.\nFor the final product case, we need to be able to take a set of two latitude and longitude and generate this.\n\nThere are basically two ways of doing this.\n1. Direct Distance\nThe ‚ÄúDirect Distance‚Äù or the ‚ÄúGreat Circle Distance‚Äù is the distance is the shortest distance between two points on a sphere (we can approximate Earth as a sphere well enough). This is given by the Haversine function which takes in the latitude and longitude of two points and returns the distance between them:\n\nLet \\(\\varphi_1\\) and \\(\\varphi_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(\\lambda_1\\) and \\(\\lambda_2\\) be the longitude of points 1 and 2 respectively.\nLet \\(r=6371.0\\) be the radius of the Earth in km.\n\nThe distance \\(d\\) between points 1 and 2 are given by: \\[\nd = 2 r \\arcsin \\left(\\sqrt{\\frac{1- \\cos (\\varphi_2-\\varphi_1)+\\cos\\varphi_1 \\cos \\varphi_2 (1-\\cos(\\lambda_2-\\lambda_1))}{2}} \\right)\n\\]\n2. Road Distance\nRealistically, road vehicles will likely never take the ‚Äòdirect‚Äô distance. The actual distance a car would travel will necessarily be greater than (or equal to) the direct distance. This is the value you get when you put a particular route into Google Maps. However, as we will see in Section¬†1.4.3, this is tricky to calculate dynamically according to user input.\n\n\n\nTo summarise the challenges in calculating the Distance Travelled:\n\nIf we use the direct distance, we can under-estimate the actual distance travelled by less than half.\nIf we use the road distance, there‚Äôs no easy way to dynamically calculate this for each user input.\n\nTo make the necessary approximations, we need two key pieces of contextual information:\n\nThe Source Location will likely be somewhere in Metropolitan Victoria, so we don‚Äôt need to consider interstate cases.\nIt‚Äôs okay to be slightly inaccurate as long as we can perform better than baseline (ie. use direct distance).\n\nAlthough we cannot dynamically calculate the road distance, it is feasible for us to pre-calculate a set of distances and uses those as reference points to approximate the actual road distance. We can use the Open Route Service API to compute road distances at a rate of approximately once every 1-2 seconds. The game plan is this:\n\nPre-Calculate the road distance from a set of reference locations.\nDynamically match the user input to one of these reference points.\nUse the reference road distance to impute for the actual road distance.\n\nAs a rule of thumb, the more granular the reference data, the more accurate the imputation. For this project, I‚Äôve opted to do this at the postcode level.\n\n\nMatthew Proctor has helpfully compiled a list of postcodes in Australia and their latitude/longitudes. First, we cut down the list to only postcodes relevant to us. We filter by the following Statistical Area level 4 (SA4) to keep only Metropolitan Melbourne postcodes:\nMETRO_SA4 = ['Melbourne - Inner', 'Melbourne - Inner East',\n       'Melbourne - Inner South', 'Melbourne - North East',\n       'Melbourne - North West', 'Melbourne - Outer East',\n       'Melbourne - South East', 'Melbourne - West']\nThis reduces the list to about 800 entries. With one API hit every 2 seconds, this will take approximately 30 minutes to calculate all the reference distances. Once we have this reference dataset, we can then match the input location to one of these reference points. There are three methods to do this in order of increasing accuracy and computational cost:\n\nThe Matched Suburb.\nThe Closest Suburb.\nThe Shortest Distance.\n\nWe ultimately used Method 1 in the final product.\n\n\n\nWhen a user provides a location, we extract the postcode from that location:\n\nIf the postcode is found in the reference list, we impute the road distance as the reference distance.\nIf the postcode is not found in the reference list, we fallback to using the direct distance and notify the user.\n\n\n\n\nThe problem with Method 1 is a location may be in postcode A but actually physically closer to the centroid of postcode B. To mitigate this problem, we can make a slight adjustment to the methodology:\n\nCalculate the direct distance between the source location and each suburb in the reference list.\nImpute the reference distance of the suburb that is ‚Äòclosest‚Äô (minimal direct distance) to the source location.\n\nThe computational cost of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the length of the reference list. Since we are running our compute on browser-side this can be a tricky tradeoff.\n\n\n\nThe problem with Method 2 is we are not considering direction. Suppose we find that postcode C is the closest match to our source location. If the centroid of postcode C is farther away than the source location from the destination location, we will be over-estimating the road distance. This logic can be applied for the case of under-estimation as well. An adjusted methodology may be:\n\nCalculate the direct distance between the source location and each suburb \\(D_{gc}^k\\) for suburb \\(k\\) .\nIf we let the reference distance from suburb \\(k\\) be \\(D_{ref}^k\\), then we would like to find \\(D = \\min (D_{gc}^k+D_{ref}^k)\\) 1.\n\nThis essentially finds the most direct path between the source and destination locations given a set of waypoints that allow us to transition into using road distances rather than direct distances.\n\n\n\n\nThe most significant, and hence interesting, blockers I faced was around implementation.\n\n\nGithub pages allowed me to easily host and serve static webpages. However, for this project, I needed to interact with user-input (either putting in a distance value or a location). Typically for reactive apps, you need to have a server to actually handle those computations.\nWhen running locally, shiny is a great tool to build the app. But how do I add that reactive component when I am hosting static webpages? Traditionally, I would have to either host my own server or rent some server to do the calculations.\nSolution: After extensive research googling, shinylive seems like the perfect solution. Rather than routing through server-side infrastructure, everything is handled on browser-side. Of course there are computational limits to what a browser can handle, but this was good enough for this usecase.\n\n\n\nTo complete the final product, we need a method to translate between a user‚Äôs location input (human language) and the latitude/longitude (machine language). This process is called geocoding. For example:\ninput = \"Antimatter Factory CERN, Geneva\"\noutput = [46.23403486205848, 6.046223317575703]\nThe geopy library has exactly this capability. However, this was when I naively walked into a perfectly laid trap. You see, geopy works perfectly well locally, so once I verified that, I started building my webapp around using this library. After significant development time, I decided to deploy a version into shinylive to see what it looks like. Here was when things started falling apart.\nYou see, shinylive comes with its own set of pre-installed packages. Notably geopyis NOT one of them. If you scroll a little more, it does suggest you can install your own packages using micropip which runs off dynode. But after hours of experimentation, I could not get it to work properly.\nSolution: Looking elsewhere, I found out that actually on the backend, geopy is essentially querying an API called Nominatim. And the best part - I can just directly query Nominatim directly! Looking elsewhere would have saved me hours of going down the micropip rabbit hole ü´†\nWhat did I learn from all of this?\n\nPackages are really dumb and annoying.\nSunk cost is real - I should have looked elsewhere far earlier.\nCheck if your things work in the actual environment before sinking significant investment into it.\n\n\n\n\nThe most computationally expensive step of the process is calculating the route between the source and destination locations. As mentioned previously, calculating this dynamically turned out to not be feasible. But why?\nComputing the route between two points requires applying route finding algorithms such as Djiakstra‚Äôs algorithm which can be computationally expensive. We can do this several ways:\n\nUse Google Maps API - by far the easiest. However Google Maps does cost money to use, so I decided not to do this.\nRun the Route Algorithm - this a free option with Open Route Service, but requires heavy computation not suitable to browser. Recall the serverless requirement!\nUse Open Route Service API - this requires an account sign up which provides a private API key. However, notably this does NOT require credit card details.\n\nSolution: I decided to go with Option 3. However, if I wanted to dynamically calculate the route according to user input, I would need to somehow expose my private API key to the end user. This is precisely because I am NOT hosting this on a server. That means there are no ways to maintain secrets from the end user.\nThis is the key motivator for approximation methods in Section¬†1.3.\n\n\n\nTo apply the approximation method, we need to read in the reference dataset which was pre-populated with road distance calculations. In a local environment, this is trivally done by using pd.read_csv(). However, shinylive deploys its own little container which doesn‚Äôt have any access to your environment.\nSolution: After some investigation there seems to be two ways of doing it:\n\nMoving data into the environment in the initialisation (couldn‚Äôt get this to work).\nRead directly from a github repo which has the reference data saved (this was selected).\n\nI opted for the latter which was the final piece of the puzzle.\n\n\n\n\nWhat did the final product look like? I have deployed a version here that you can check out here\nWhat did I learn from this experience:\n\nDon‚Äôt get too stuck on a single solution.\nPackage management is an awful problem.\nSomething is better than nothing."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#the-design-phase",
    "href": "posts/first-shiny-app/index.html#the-design-phase",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "Okay, so at the core of it, I needed an app that took in the following inputs:\n\nSource Location - where is the user coming from?\nNumber of Pax - how many people do we split the cost over?\n\nThe destination location is fixed for simplicity since we were all going to the same place for the trip. This will save us some complexity as we will soon see.\nAfter the user clicks ‚Äòsubmit‚Äô, I want to compute & display:\n\nDistance Travelled - there is a degree of ambiguity to this as we will soon see.\nCost per Pax - this is the target metric to calculate.\nA map - maps are fun üó∫Ô∏è\n\n\n\nSince this is my first webapp, I am not even sure of the infrastructure needed to build this solution. To make sure the project is feasible, I begin with a cut-down version of the requirements. Suppose the user already provides the Distance Travelled (say with a Google Maps search), let‚Äôs see if we can calculate the target metric of Cost per Pax.\nLet \\(C\\) be the cost per pax measure we want to calculate. Let:\n\n\\(\\epsilon\\) be the fuel efficiency. For this we used 0.1 L/km according to carsguide for a typical SUV.\n\\(\\varphi\\) be the fuel cost per litre. For this we take the estimate of $2.5.\n\\(D\\) be the distance travelled in km.\n\\(n\\) be the number of pax.\n\n\\[\nC = \\frac{\\epsilon\\varphi D}{n} = \\frac{0.25D}{n}\n\\]\n\n\n\nIn the final product, we want to go one step further and find a way to map between the Source Location and the Distance Travelled. The generic steps are:\n\nUser provides the source location in text string.\nThis text is mapped to a lattitude and longitude.\nThe distance between this source location and the destination location is calculated."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#a-scenic-route-what-is-distance-travelled",
    "href": "posts/first-shiny-app/index.html#a-scenic-route-what-is-distance-travelled",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "There is some ambiguity in the definition of Distance Travelled.\n\nFor the MVP case, this parameter is provided a priori.\nFor the final product case, we need to be able to take a set of two latitude and longitude and generate this.\n\nThere are basically two ways of doing this.\n1. Direct Distance\nThe ‚ÄúDirect Distance‚Äù or the ‚ÄúGreat Circle Distance‚Äù is the distance is the shortest distance between two points on a sphere (we can approximate Earth as a sphere well enough). This is given by the Haversine function which takes in the latitude and longitude of two points and returns the distance between them:\n\nLet \\(\\varphi_1\\) and \\(\\varphi_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(\\lambda_1\\) and \\(\\lambda_2\\) be the longitude of points 1 and 2 respectively.\nLet \\(r=6371.0\\) be the radius of the Earth in km.\n\nThe distance \\(d\\) between points 1 and 2 are given by: \\[\nd = 2 r \\arcsin \\left(\\sqrt{\\frac{1- \\cos (\\varphi_2-\\varphi_1)+\\cos\\varphi_1 \\cos \\varphi_2 (1-\\cos(\\lambda_2-\\lambda_1))}{2}} \\right)\n\\]\n2. Road Distance\nRealistically, road vehicles will likely never take the ‚Äòdirect‚Äô distance. The actual distance a car would travel will necessarily be greater than (or equal to) the direct distance. This is the value you get when you put a particular route into Google Maps. However, as we will see in Section¬†1.4.3, this is tricky to calculate dynamically according to user input."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#sec-approx",
    "href": "posts/first-shiny-app/index.html#sec-approx",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "To summarise the challenges in calculating the Distance Travelled:\n\nIf we use the direct distance, we can under-estimate the actual distance travelled by less than half.\nIf we use the road distance, there‚Äôs no easy way to dynamically calculate this for each user input.\n\nTo make the necessary approximations, we need two key pieces of contextual information:\n\nThe Source Location will likely be somewhere in Metropolitan Victoria, so we don‚Äôt need to consider interstate cases.\nIt‚Äôs okay to be slightly inaccurate as long as we can perform better than baseline (ie. use direct distance).\n\nAlthough we cannot dynamically calculate the road distance, it is feasible for us to pre-calculate a set of distances and uses those as reference points to approximate the actual road distance. We can use the Open Route Service API to compute road distances at a rate of approximately once every 1-2 seconds. The game plan is this:\n\nPre-Calculate the road distance from a set of reference locations.\nDynamically match the user input to one of these reference points.\nUse the reference road distance to impute for the actual road distance.\n\nAs a rule of thumb, the more granular the reference data, the more accurate the imputation. For this project, I‚Äôve opted to do this at the postcode level.\n\n\nMatthew Proctor has helpfully compiled a list of postcodes in Australia and their latitude/longitudes. First, we cut down the list to only postcodes relevant to us. We filter by the following Statistical Area level 4 (SA4) to keep only Metropolitan Melbourne postcodes:\nMETRO_SA4 = ['Melbourne - Inner', 'Melbourne - Inner East',\n       'Melbourne - Inner South', 'Melbourne - North East',\n       'Melbourne - North West', 'Melbourne - Outer East',\n       'Melbourne - South East', 'Melbourne - West']\nThis reduces the list to about 800 entries. With one API hit every 2 seconds, this will take approximately 30 minutes to calculate all the reference distances. Once we have this reference dataset, we can then match the input location to one of these reference points. There are three methods to do this in order of increasing accuracy and computational cost:\n\nThe Matched Suburb.\nThe Closest Suburb.\nThe Shortest Distance.\n\nWe ultimately used Method 1 in the final product.\n\n\n\nWhen a user provides a location, we extract the postcode from that location:\n\nIf the postcode is found in the reference list, we impute the road distance as the reference distance.\nIf the postcode is not found in the reference list, we fallback to using the direct distance and notify the user.\n\n\n\n\nThe problem with Method 1 is a location may be in postcode A but actually physically closer to the centroid of postcode B. To mitigate this problem, we can make a slight adjustment to the methodology:\n\nCalculate the direct distance between the source location and each suburb in the reference list.\nImpute the reference distance of the suburb that is ‚Äòclosest‚Äô (minimal direct distance) to the source location.\n\nThe computational cost of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the length of the reference list. Since we are running our compute on browser-side this can be a tricky tradeoff.\n\n\n\nThe problem with Method 2 is we are not considering direction. Suppose we find that postcode C is the closest match to our source location. If the centroid of postcode C is farther away than the source location from the destination location, we will be over-estimating the road distance. This logic can be applied for the case of under-estimation as well. An adjusted methodology may be:\n\nCalculate the direct distance between the source location and each suburb \\(D_{gc}^k\\) for suburb \\(k\\) .\nIf we let the reference distance from suburb \\(k\\) be \\(D_{ref}^k\\), then we would like to find \\(D = \\min (D_{gc}^k+D_{ref}^k)\\) 1.\n\nThis essentially finds the most direct path between the source and destination locations given a set of waypoints that allow us to transition into using road distances rather than direct distances."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#the-blockers",
    "href": "posts/first-shiny-app/index.html#the-blockers",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "The most significant, and hence interesting, blockers I faced was around implementation.\n\n\nGithub pages allowed me to easily host and serve static webpages. However, for this project, I needed to interact with user-input (either putting in a distance value or a location). Typically for reactive apps, you need to have a server to actually handle those computations.\nWhen running locally, shiny is a great tool to build the app. But how do I add that reactive component when I am hosting static webpages? Traditionally, I would have to either host my own server or rent some server to do the calculations.\nSolution: After extensive research googling, shinylive seems like the perfect solution. Rather than routing through server-side infrastructure, everything is handled on browser-side. Of course there are computational limits to what a browser can handle, but this was good enough for this usecase.\n\n\n\nTo complete the final product, we need a method to translate between a user‚Äôs location input (human language) and the latitude/longitude (machine language). This process is called geocoding. For example:\ninput = \"Antimatter Factory CERN, Geneva\"\noutput = [46.23403486205848, 6.046223317575703]\nThe geopy library has exactly this capability. However, this was when I naively walked into a perfectly laid trap. You see, geopy works perfectly well locally, so once I verified that, I started building my webapp around using this library. After significant development time, I decided to deploy a version into shinylive to see what it looks like. Here was when things started falling apart.\nYou see, shinylive comes with its own set of pre-installed packages. Notably geopyis NOT one of them. If you scroll a little more, it does suggest you can install your own packages using micropip which runs off dynode. But after hours of experimentation, I could not get it to work properly.\nSolution: Looking elsewhere, I found out that actually on the backend, geopy is essentially querying an API called Nominatim. And the best part - I can just directly query Nominatim directly! Looking elsewhere would have saved me hours of going down the micropip rabbit hole ü´†\nWhat did I learn from all of this?\n\nPackages are really dumb and annoying.\nSunk cost is real - I should have looked elsewhere far earlier.\nCheck if your things work in the actual environment before sinking significant investment into it.\n\n\n\n\nThe most computationally expensive step of the process is calculating the route between the source and destination locations. As mentioned previously, calculating this dynamically turned out to not be feasible. But why?\nComputing the route between two points requires applying route finding algorithms such as Djiakstra‚Äôs algorithm which can be computationally expensive. We can do this several ways:\n\nUse Google Maps API - by far the easiest. However Google Maps does cost money to use, so I decided not to do this.\nRun the Route Algorithm - this a free option with Open Route Service, but requires heavy computation not suitable to browser. Recall the serverless requirement!\nUse Open Route Service API - this requires an account sign up which provides a private API key. However, notably this does NOT require credit card details.\n\nSolution: I decided to go with Option 3. However, if I wanted to dynamically calculate the route according to user input, I would need to somehow expose my private API key to the end user. This is precisely because I am NOT hosting this on a server. That means there are no ways to maintain secrets from the end user.\nThis is the key motivator for approximation methods in Section¬†1.3.\n\n\n\nTo apply the approximation method, we need to read in the reference dataset which was pre-populated with road distance calculations. In a local environment, this is trivally done by using pd.read_csv(). However, shinylive deploys its own little container which doesn‚Äôt have any access to your environment.\nSolution: After some investigation there seems to be two ways of doing it:\n\nMoving data into the environment in the initialisation (couldn‚Äôt get this to work).\nRead directly from a github repo which has the reference data saved (this was selected).\n\nI opted for the latter which was the final piece of the puzzle."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#conclusions",
    "href": "posts/first-shiny-app/index.html#conclusions",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "What did the final product look like? I have deployed a version here that you can check out here\nWhat did I learn from this experience:\n\nDon‚Äôt get too stuck on a single solution.\nPackage management is an awful problem.\nSomething is better than nothing."
  },
  {
    "objectID": "posts/first-shiny-app/index.html#footnotes",
    "href": "posts/first-shiny-app/index.html#footnotes",
    "title": "Building my first webapp with shinylive",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNotational abuse for brevity‚Äôs sake.‚Ü©Ô∏é"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog Posts",
    "section": "",
    "text": "Having Sum Fun\n\n\n\n\n\n\nMathematics\n\n\nRiemann-Zeta\n\n\nAnalysis\n\n\nGeometry\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding my first webapp with shinylive\n\n\n\n\n\n\nDevOps\n\n\nGeoData\n\n\nShiny\n\n\nPython\n\n\n\n\n\n\n\n\n\nAug 16, 2025\n\n\n\n\n\n\nNo matching items"
  }
]