[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this Blog",
    "section": "",
    "text": "Hello üëã Welcome to my blog!!! This place is a repository of ideas I want to understand better. What better pedegogical technique than to follow the path of Feynman and (as best as I can) explain them in as simple terms as I can muster? Hence this blog.\nWho am I?\n24601 üéµ\nJust kidding‚Ä¶ I currently do a bit of Cloud (AWS) Engineering to earn my keep, although I‚Äôve come from more of a Data Science & Data Engineering background. My training was in experimental particle physics - an area that I‚Äôm still very much interested in and am keen to use this blog to explore."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog Posts",
    "section": "",
    "text": "Building my first webapp with shinylive\n\n\n\n\n\n\nDevOps\n\n\nGeoData\n\n\nShiny\n\n\nPython\n\n\n\n\n\n\n\n\n\nAug 8, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/first-deploy/index.html",
    "href": "posts/first-deploy/index.html",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "As I was planning a road trip with friends, I wondered if there was an easy way to estimate the fuel cost for each individual. Nothing out there seemed to meet the usecase I had, so I decided to build a webapp. What I thought was a quick and easy solution ended up taking ~20hr to develop, but given this was more about pedegogy than perfection, it was time well-spent.\nI began with three important considerations:\n\nüñ•Ô∏è Serverless - I don‚Äôt want to spin up a server just for this - it needs to be hostable on github.\nüí∞ Free - I don‚Äôt want to pay for anything, even if I‚Äôm adding a credit card to access a ‚Äúfree tier‚Äù.\nüö¢ Simple - I don‚Äôt want to spend time on something that won‚Äôt be shipped.\n\n\n\nOkay, so at the core of it, I needed an app that took in the following inputs:\n\nSource Location - where is the user coming from?\nNumber of Pax - how many people do we split the cost over?\n\nThe destination location is fixed for simplicity since we were all going to the same place for the trip. This will save us some complexity as we will soon see.\nAfter the user clicks ‚Äòsubmit‚Äô, I want to compute & display:\n\nDistance Travelled - there is a degree of ambiguity to this as we will soon see.\nCost per Pax - this is the target metric to calculate.\nA map - maps are fun üó∫Ô∏è\n\n\n\nSince this is my first webapp, I am not even sure of the infrastructure needed to build this solution. To make sure the project is feasible, I begin with a cut-down version of the requirements. Suppose the user already provides the Distance Travelled (say with a Google Maps search), let‚Äôs see if we can calculate the target metric of Cost per Pax.\nLet \\(C\\) be the cost per pax measure we want to calculate. Let:\n\n\\(\\epsilon\\) be the fuel efficiency. For this we used 0.1 L/km according to carsguide for a typical SUV.\n\\(\\varphi\\) be the fuel cost per litre. For this we take the estimate of $2.5.\n\\(D\\) be the distance travelled in km.\n\\(n\\) be the number of pax.\n\n\\[\nC = \\frac{\\epsilon\\varphi D}{n} = \\frac{0.25D}{n}\n\\]\n\n\n\nIn the final product, we want to go one step further and find a way to map between the Source Location and the Distance Travelled. The generic steps are:\n\nUser provides the source location in text string.\nThis text is mapped to a lattitude and longitude.\nThe distance between this source location and the destination location is calculated.\n\n\n\n\n\nThere is some ambiguity in the definition of Distance Travelled.\n\nFor the MVP case, this parameter is provided a priori.\nFor the final product case, we need to be able to take a set of two latitude and longitude and generate this.\n\nThere are basically two ways of doing this.\n1. Direct Distance\nThe ‚ÄúDirect Distance‚Äù or the ‚ÄúGreat Circle Distance‚Äù is the distance is the shortest distance between two points on a sphere (we can approximate Earth as a sphere well enough). This is given by the Haversine function which takes in the latitude and longitude of two points and returns the distance between them:\n\nLet \\(\\varphi_1\\) and \\(\\varphi_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(\\lambda_1\\) and \\(\\lambda_2\\) be the longitude of points 1 and 2 respectively.\nLet \\(r=6371.0\\) be the radius of the Earth in km.\n\nThe distance \\(d\\) between points 1 and 2 are given by: \\[\nd = 2 r \\arcsin \\left(\\sqrt{\\frac{1- \\cos (\\varphi_2-\\varphi_1)+\\cos\\varphi_1 \\cos \\varphi_2 (1-\\cos(\\lambda_2-\\lambda_1))}{2}} \\right)\n\\]\n2. Road Distance\nRealistically, road vehicles will likely never take the ‚Äòdirect‚Äô distance. The actual distance a car would travel will necessarily be greater than (or equal to) the direct distance. This is the value you get when you put a particular route into Google Maps. However, as we will see in Section¬†1.4.3, this is tricky to calculate dynamically according to user input.\n\n\n\nTo summarise the challenges in calculating the Distance Travelled:\n\nIf we use the direct distance, we can under-estimate the actual distance travelled by less than half.\nIf we use the road distance, there‚Äôs no easy way to dynamically calculate this for each user input.\n\nTo make the necessary approximations, we need two key pieces of contextual information:\n\nThe Source Location will likely be somewhere in Metropolitan Victoria, so we don‚Äôt need to consider interstate cases.\nIt‚Äôs okay to be slightly inaccurate as long as we can perform better than baseline (ie. use direct distance).\n\nAlthough we cannot dynamically calculate the road distance, it is feasible for us to pre-calculate a set of distances and uses those as reference points to approximate the actual road distance. We can use the Open Route Service API to compute road distances at a rate of approximately once every 1-2 seconds. The game plan is this:\n\nPre-Calculate the road distance from a set of reference locations.\nDynamically match the user input to one of these reference points.\nUse the reference road distance to impute for the actual road distance.\n\nAs a rule of thumb, the more granular the reference data, the more accurate the imputation. For this project, I‚Äôve opted to do this at the postcode level.\n\n\nMatthew Proctor has helpfully compiled a list of postcodes in Australia and their latitude/longitudes. First, we cut down the list to only postcodes relevant to us. We filter by the following Statistical Area level 4 (SA4) to keep only Metropolitan Melbourne postcodes:\nMETRO_SA4 = ['Melbourne - Inner', 'Melbourne - Inner East',\n       'Melbourne - Inner South', 'Melbourne - North East',\n       'Melbourne - North West', 'Melbourne - Outer East',\n       'Melbourne - South East', 'Melbourne - West']\nThis reduces the list to about 800 entries. With one API hit every 2 seconds, this will take approximately 30 minutes to calculate all the reference distances. Once we have this reference dataset, we can then match the input location to one of these reference points. There are three methods to do this in order of increasing accuracy and computational cost:\n\nThe Matched Suburb.\nThe Closest Suburb.\nThe Shortest Distance.\n\nWe ultimately used Method 1 in the final product.\n\n\n\nWhen a user provides a location, we extract the postcode from that location:\n\nIf the postcode is found in the reference list, we impute the road distance as the reference distance.\nIf the postcode is not found in the reference list, we fallback to using the direct distance and notify the user.\n\n\n\n\nThe problem with Method 1 is a location may be in postcode A but actually physically closer to the centroid of postcode B. To mitigate this problem, we can make a slight adjustment to the methodology:\n\nCalculate the direct distance between the source location and each suburb in the reference list.\nImpute the reference distance of the suburb that is ‚Äòclosest‚Äô (minimal direct distance) to the source location.\n\nThe computational cost of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the length of the reference list. Since we are running our compute on browser-side this can be a tricky tradeoff.\n\n\n\nThe problem with Method 2 is we are not considering direction. Suppose we find that postcode C is the closest match to our source location. If the centroid of postcode C is farther away than the source location from the destination location, we will be over-estimating the road distance. This logic can be applied for the case of under-estimation as well. An adjusted methodology may be:\n\nCalculate the direct distance between the source location and each suburb \\(D_{gc}^k\\) for suburb \\(k\\) .\nIf we let the reference distance from suburb \\(k\\) be \\(D_{ref}^k\\), then we would like to find \\(D = \\min (D_{gc}^k+D_{ref}^k)\\) 1.\n\nThis essentially finds the most direct path between the source and destination locations given a set of waypoints that allow us to transition into using road distances rather than direct distances.\n\n\n\n\nThe most significant, and hence interesting, blockers I faced was around implementation.\n\n\nGithub pages allowed me to easily host and serve static webpages. However, for this project, I needed to interact with user-input (either putting in a distance value or a location). Typically for reactive apps, you need to have a server to actually handle those computations.\nWhen running locally, shiny is a great tool to build the app. But how do I add that reactive component when I am hosting static webpages? Traditionally, I would have to either host my own server or rent some server to do the calculations.\nSolution: After extensive research googling, shinylive seems like the perfect solution. Rather than routing through server-side infrastructure, everything is handled on browser-side. Of course there are computational limits to what a browser can handle, but this was good enough for this usecase.\n\n\n\nTo complete the final product, we need a method to translate between a user‚Äôs location input (human language) and the latitude/longitude (machine language). This process is called geocoding. For example:\ninput = \"Antimatter Factory CERN, Geneva\"\noutput = [46.23403486205848, 6.046223317575703]\nThe geopy library has exactly this capability. However, this was when I naively walked into a perfectly laid trap. You see, geopy works perfectly well locally, so once I verified that, I started building my webapp around using this library. After significant development time, I decided to deploy a version into shinylive to see what it looks like. Here was when things started falling apart.\nYou see, shinylive comes with its own set of pre-installed packages. Notably geopyis NOT one of them. If you scroll a little more, it does suggest you can install your own packages using micropip which runs off dynode. But after hours of experimentation, I could not get it to work properly.\nSolution: Looking elsewhere, I found out that actually on the backend, geopy is essentially querying an API called Nominatim. And the best part - I can just directly query Nominatim directly! Looking elsewhere would have saved me hours of going down the micropip rabbit hole ü´†\nWhat did I learn from all of this?\n\nPackages are really dumb and annoying.\nSunk cost is real - I should have looked elsewhere far earlier.\nCheck if your things work in the actual environment before sinking significant investment into it.\n\n\n\n\nThe most computationally expensive step of the process is calculating the route between the source and destination locations. As mentioned previously, calculating this dynamically turned out to not be feasible. But why?\nComputing the route between two points requires applying route finding algorithms such as Djiakstra‚Äôs algorithm which can be computationally expensive. We can do this several ways:\n\nUse Google Maps API - by far the easiest. However Google Maps does cost money to use, so I decided not to do this.\nRun the Route Algorithm - this a free option with Open Route Service, but requires heavy computation not suitable to browser. Recall the serverless requirement!\nUse Open Route Service API - this requires an account sign up which provides a private API key. However, notably this does NOT require credit card details.\n\nSolution: I decided to go with Option 3. However, if I wanted to dynamically calculate the route according to user input, I would need to somehow expose my private API key to the end user. This is precisely because I am NOT hosting this on a server. That means there are no ways to maintain secrets from the end user.\nThis is the key motivator for approximation methods in Section¬†1.3.\n\n\n\nTo apply the approximation method, we need to read in the reference dataset which was pre-populated with road distance calculations. In a local environment, this is trivally done by using pd.read_csv(). However, shinylive deploys its own little container which doesn‚Äôt have any access to your environment.\nSolution: After some investigation there seems to be two ways of doing it:\n\nMoving data into the environment in the initialisation (couldn‚Äôt get this to work).\nRead directly from a github repo which has the reference data saved (this was selected).\n\nI opted for the latter which was the final piece of the puzzle.\n\n\n\n\nWhat did the final product look like? I have deployed a version here that you can check out here\nWhat did I learn from this experience:\n\nDon‚Äôt get too stuck on a single solution.\nPackage management is an awful problem.\nSomething is better than nothing."
  },
  {
    "objectID": "posts/first-deploy/index.html#the-design-phase",
    "href": "posts/first-deploy/index.html#the-design-phase",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "Okay, so at the core of it, I needed an app that took in the following inputs:\n\nSource Location - where is the user coming from?\nNumber of Pax - how many people do we split the cost over?\n\nThe destination location is fixed for simplicity since we were all going to the same place for the trip. This will save us some complexity as we will soon see.\nAfter the user clicks ‚Äòsubmit‚Äô, I want to compute & display:\n\nDistance Travelled - there is a degree of ambiguity to this as we will soon see.\nCost per Pax - this is the target metric to calculate.\nA map - maps are fun üó∫Ô∏è\n\n\n\nSince this is my first webapp, I am not even sure of the infrastructure needed to build this solution. To make sure the project is feasible, I begin with a cut-down version of the requirements. Suppose the user already provides the Distance Travelled (say with a Google Maps search), let‚Äôs see if we can calculate the target metric of Cost per Pax.\nLet \\(C\\) be the cost per pax measure we want to calculate. Let:\n\n\\(\\epsilon\\) be the fuel efficiency. For this we used 0.1 L/km according to carsguide for a typical SUV.\n\\(\\varphi\\) be the fuel cost per litre. For this we take the estimate of $2.5.\n\\(D\\) be the distance travelled in km.\n\\(n\\) be the number of pax.\n\n\\[\nC = \\frac{\\epsilon\\varphi D}{n} = \\frac{0.25D}{n}\n\\]\n\n\n\nIn the final product, we want to go one step further and find a way to map between the Source Location and the Distance Travelled. The generic steps are:\n\nUser provides the source location in text string.\nThis text is mapped to a lattitude and longitude.\nThe distance between this source location and the destination location is calculated."
  },
  {
    "objectID": "posts/first-deploy/index.html#the-mvp",
    "href": "posts/first-deploy/index.html#the-mvp",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "Since this is my first webapp, I am not even sure of the infrastructured needed to build this solution. To make sure the project is feasible, I begin with a cut-down version of the requirements. Suppose the user already provides the Distance Travelled (say with a Google Maps search), let‚Äôs see if we can calculate the target metric if Cost per Pax.\nLet \\(C\\) be the cost per pax measure we want to calculate. Let:\n\n\\(\\epsilon\\) be the fuel efficiency. For this we used 0.1 L/km according to carsguide for a typical SUV.\n\\(\\varphi\\) be the fuel cost per litre. For this we take the estimate of $2.5.\n\\(D\\) be the distance travelled in km.\n\\(n\\) be the number of pax.\n\n\\[\nC = \\frac{\\epsilon\\varphi D}{n} = \\frac{0.25D}{n}\n\\]"
  },
  {
    "objectID": "posts/first-deploy/index.html#the-blockers",
    "href": "posts/first-deploy/index.html#the-blockers",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "The most significant, and hence interesting, blockers I faced was around implementation.\n\n\nGithub pages allowed me to easily host and serve static webpages. However, for this project, I needed to interact with user-input (either putting in a distance value or a location). Typically for reactive apps, you need to have a server to actually handle those computations.\nWhen running locally, shiny is a great tool to build the app. But how do I add that reactive component when I am hosting static webpages? Traditionally, I would have to either host my own server or rent some server to do the calculations.\nSolution: After extensive research googling, shinylive seems like the perfect solution. Rather than routing through server-side infrastructure, everything is handled on browser-side. Of course there are computational limits to what a browser can handle, but this was good enough for this usecase.\n\n\n\nTo complete the final product, we need a method to translate between a user‚Äôs location input (human language) and the latitude/longitude (machine language). This process is called geocoding. For example:\ninput = \"Antimatter Factory CERN, Geneva\"\noutput = [46.23403486205848, 6.046223317575703]\nThe geopy library has exactly this capability. However, this was when I naively walked into a perfectly laid trap. You see, geopy works perfectly well locally, so once I verified that, I started building my webapp around using this library. After significant development time, I decided to deploy a version into shinylive to see what it looks like. Here was when things started falling apart.\nYou see, shinylive comes with its own set of pre-installed packages. Notably geopyis NOT one of them. If you scroll a little more, it does suggest you can install your own packages using micropip which runs off dynode. But after hours of experimentation, I could not get it to work properly.\nSolution: Looking elsewhere, I found out that actually on the backend, geopy is essentially querying an API called Nominatim. And the best part - I can just directly query Nominatim directly! Looking elsewhere would have saved me hours of going down the micropip rabbit hole ü´†\nWhat did I learn from all of this?\n\nPackages are really dumb and annoying.\nSunk cost is real - I should have looked elsewhere far earlier.\nCheck if your things work in the actual environment before sinking significant investment into it.\n\n\n\n\nThe most computationally expensive step of the process is calculating the route between the source and destination locations. As mentioned previously, calculating this dynamically turned out to not be feasible. But why?\nComputing the route between two points requires applying route finding algorithms such as Djiakstra‚Äôs algorithm which can be computationally expensive. We can do this several ways:\n\nUse Google Maps API - by far the easiest. However Google Maps does cost money to use, so I decided not to do this.\nRun the Route Algorithm - this a free option with Open Route Service, but requires heavy computation not suitable to browser. Recall the serverless requirement!\nUse Open Route Service API - this requires an account sign up which provides a private API key. However, notably this does NOT require credit card details.\n\nSolution: I decided to go with Option 3. However, if I wanted to dynamically calculate the route according to user input, I would need to somehow expose my private API key to the end user. This is precisely because I am NOT hosting this on a server. That means there are no ways to maintain secrets from the end user.\nThis is the key motivator for approximation methods in Section¬†1.3.\n\n\n\nTo apply the approximation method, we need to read in the reference dataset which was pre-populated with road distance calculations. In a local environment, this is trivally done by using pd.read_csv(). However, shinylive deploys its own little container which doesn‚Äôt have any access to your environment.\nSolution: After some investigation there seems to be two ways of doing it:\n\nMoving data into the environment in the initialisation (couldn‚Äôt get this to work).\nRead directly from a github repo which has the reference data saved (this was selected).\n\nI opted for the latter which was the final piece of the puzzle."
  },
  {
    "objectID": "posts/first-deploy/index.html#conclusions",
    "href": "posts/first-deploy/index.html#conclusions",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "What did the final product look like? I have deployed a version here that you can check out here\nWhat did I learn from this experience:\n\nDon‚Äôt get too stuck on a single solution.\nPackage management is an awful problem.\nSomething is better than nothing."
  },
  {
    "objectID": "posts/first-deploy/index.html#the-approximations",
    "href": "posts/first-deploy/index.html#the-approximations",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "So there is even ambiguity in the Distance Travelled.\n\nIf we use the direct distance, we can under-estimate the actual distance travelled by less than half.\nIf we use the road distance, there‚Äôs no easy way to dynamically calculate this for each user input.\n\nWhen we are stuck like this, we can often make approximations. Here are two important pieces of contextual information:\n\nThe Source Location will likely be somewhere in Metropolitan Victoria, so we don‚Äôt need to consider interstate cases.\nIt‚Äôs okay to be slightly inaccurate as long as we can perform better than baseline (ie. use direct distance).\n\nAlthough we cannot dynamically calculate the road distance, it is feasible for us to pre-calculate a set of distances and uses those as reference points to approximate the actual road distance. We have access to an API which can compute this for us at a rate of approximately once every 1-2 seconds. The game plan is this:\n\nPre-Calculate the road distance from a set of reference locations.\nDynamically match the user input to one of these reference points.\nUse the reference road distance to impute for the actual road distance.\n\nAs a rule of thumb, the more granular the reference data, the more accurate the imputation. For this project, I‚Äôve opted to do this at the postcode level.\n\n\nMatthew Proctor has helpfully compiled a list of postcodes in Australia and their latitude/longitudes. First, we cut down the list to only postcodes relevant to us. We filter by the following Statistical Area level 4 (SA4) to keep only Metropolitan Melbourne postcodes:\nMETRO_SA4 = ['Melbourne - Inner', 'Melbourne - Inner East',\n       'Melbourne - Inner South', 'Melbourne - North East',\n       'Melbourne - North West', 'Melbourne - Outer East',\n       'Melbourne - South East', 'Melbourne - West']\nThis reduces the list to about 800 entries. With one API hit every 2 seconds, this will take approximately 30 minutes to calculate all the reference distances. Once we have this reference dataset, we can then match the input location to one of these reference points. There are three methods to do this in order of increasing accuracy and computational cost:\n\nThe Matched Suburb.\nThe Closest Suburb.\nThe Shortest Distance.\n\nWe ultimately used Method 1 in the final product.\n\n\n\nWhen a user provides a location, we extract the postcode from that location:\n\nIf the postcode is found in the reference list, we impute the road distance as the reference distance.\nIf the postcode is not found in the reference list, we fallback to using the direct distance and notify the user.\n\n\n\n\nThe problem with Method 1 is a location may be in postcode A but actually physically closer to the centroid of postcode B. To mitigate this problem, we can make a slight adjustment to the methodology:\n\nCalculate the direct distance between the source location and each suburb in the reference list.\nImpute the reference distance of the suburb that is ‚Äòclosest‚Äô (minimal direct distance) to the source location.\n\nThe computational cost of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the length of the reference list. Since we are running our compute on browser-side this can be a tricky tradeoff.\n\n\n\nThe problem with Method 2 is we are not considering direction. Suppose postcode B is the closest reference point the source location, however, if it lies in the opposite direction to the destination location, we are now overestimating the road distance. The same can be said of the other way around. An adjusted methodology may be:\n\nCalculate the direct distance between the source location and each suburb \\(D_{gc}^k\\) for suburb \\(k\\) .\nIf we let the reference distance from suburb \\(k\\) be \\(D_{ref}^k\\), then we would like to find \\(D = \\min (D_{gc}^k+D_{ref}^k)\\) 1."
  },
  {
    "objectID": "posts/first-deploy/index.html#the-scenic-route-what-is-distance-travelled",
    "href": "posts/first-deploy/index.html#the-scenic-route-what-is-distance-travelled",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "In the MVP case, we just assumed the user provides the Distance Travelled, but how is this actually obtained? Well realistically the user will probably search up the route on Google Maps and then use that distance. When measuring distance between two points on Earth there is realistically two distances.\n1. Direct Distance\nThe ‚ÄúDirect Distance‚Äù or the ‚ÄúGreat Circle Distance‚Äù is the distance is the shortest distance between two points on a sphere (we can approximate Earth as a sphere well enough LINK). This is given by the Haversine function which takes in the latitude and longitude of two points and returns the distance between them:\n\nLet \\(\\varphi_1\\) and \\(\\varphi_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(\\lambda_1\\) and \\(\\lambda_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(r=6371.0\\) be the radius of the Earth in km.\n\nThe distance \\(d\\) between points 1 and 2 are: \\[\nd = 2 r \\arcsin \\left(\\sqrt{\\frac{1- \\cos (\\varphi_2-\\varphi_1)+\\cos\\varphi_1 \\cos \\varphi_2 (1-\\cos(\\lambda_2-\\lambda_1))}{2}} \\right)\n\\]\n2. Road Distance\nRealistically the distance taken by a car between two points will be far from the direct distance. By definition, the road distance will always be greater than the direct distance. Given the few data points I did try, the road distance can even be double that of the direct distance.\nThe tricky thing is the road distance will be quite complex to calculate as we will see later. The road distance requires the use of an API dynamically calcualte the route according to user inputs. However, this is very tricky in practically as we shall soon see in Blocker #3."
  },
  {
    "objectID": "posts/first-deploy/index.html#a-scenic-route-what-is-distance-travelled",
    "href": "posts/first-deploy/index.html#a-scenic-route-what-is-distance-travelled",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "There is some ambiguity in the definition of Distance Travelled.\n\nFor the MVP case, this parameter is provided a priori.\nFor the final product case, we need to be able to take a set of two latitude and longitude and generate this.\n\nThere are basically two ways of doing this.\n1. Direct Distance\nThe ‚ÄúDirect Distance‚Äù or the ‚ÄúGreat Circle Distance‚Äù is the distance is the shortest distance between two points on a sphere (we can approximate Earth as a sphere well enough). This is given by the Haversine function which takes in the latitude and longitude of two points and returns the distance between them:\n\nLet \\(\\varphi_1\\) and \\(\\varphi_2\\) be the latitude of points 1 and 2 respectively.\nLet \\(\\lambda_1\\) and \\(\\lambda_2\\) be the longitude of points 1 and 2 respectively.\nLet \\(r=6371.0\\) be the radius of the Earth in km.\n\nThe distance \\(d\\) between points 1 and 2 are given by: \\[\nd = 2 r \\arcsin \\left(\\sqrt{\\frac{1- \\cos (\\varphi_2-\\varphi_1)+\\cos\\varphi_1 \\cos \\varphi_2 (1-\\cos(\\lambda_2-\\lambda_1))}{2}} \\right)\n\\]\n2. Road Distance\nRealistically, road vehicles will likely never take the ‚Äòdirect‚Äô distance. The actual distance a car would travel will necessarily be greater than (or equal to) the direct distance. This is the value you get when you put a particular route into Google Maps. However, as we will see in Section¬†1.4.3, this is tricky to calculate dynamically according to user input."
  },
  {
    "objectID": "posts/first-deploy/index.html#footnotes",
    "href": "posts/first-deploy/index.html#footnotes",
    "title": "Building my first webapp with shinylive",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNotational abuse for brevity‚Äôs sake.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/first-deploy/index.html#sec-approx",
    "href": "posts/first-deploy/index.html#sec-approx",
    "title": "Building my first webapp with shinylive",
    "section": "",
    "text": "To summarise the challenges in calculating the Distance Travelled:\n\nIf we use the direct distance, we can under-estimate the actual distance travelled by less than half.\nIf we use the road distance, there‚Äôs no easy way to dynamically calculate this for each user input.\n\nTo make the necessary approximations, we need two key pieces of contextual information:\n\nThe Source Location will likely be somewhere in Metropolitan Victoria, so we don‚Äôt need to consider interstate cases.\nIt‚Äôs okay to be slightly inaccurate as long as we can perform better than baseline (ie. use direct distance).\n\nAlthough we cannot dynamically calculate the road distance, it is feasible for us to pre-calculate a set of distances and uses those as reference points to approximate the actual road distance. We can use the Open Route Service API to compute road distances at a rate of approximately once every 1-2 seconds. The game plan is this:\n\nPre-Calculate the road distance from a set of reference locations.\nDynamically match the user input to one of these reference points.\nUse the reference road distance to impute for the actual road distance.\n\nAs a rule of thumb, the more granular the reference data, the more accurate the imputation. For this project, I‚Äôve opted to do this at the postcode level.\n\n\nMatthew Proctor has helpfully compiled a list of postcodes in Australia and their latitude/longitudes. First, we cut down the list to only postcodes relevant to us. We filter by the following Statistical Area level 4 (SA4) to keep only Metropolitan Melbourne postcodes:\nMETRO_SA4 = ['Melbourne - Inner', 'Melbourne - Inner East',\n       'Melbourne - Inner South', 'Melbourne - North East',\n       'Melbourne - North West', 'Melbourne - Outer East',\n       'Melbourne - South East', 'Melbourne - West']\nThis reduces the list to about 800 entries. With one API hit every 2 seconds, this will take approximately 30 minutes to calculate all the reference distances. Once we have this reference dataset, we can then match the input location to one of these reference points. There are three methods to do this in order of increasing accuracy and computational cost:\n\nThe Matched Suburb.\nThe Closest Suburb.\nThe Shortest Distance.\n\nWe ultimately used Method 1 in the final product.\n\n\n\nWhen a user provides a location, we extract the postcode from that location:\n\nIf the postcode is found in the reference list, we impute the road distance as the reference distance.\nIf the postcode is not found in the reference list, we fallback to using the direct distance and notify the user.\n\n\n\n\nThe problem with Method 1 is a location may be in postcode A but actually physically closer to the centroid of postcode B. To mitigate this problem, we can make a slight adjustment to the methodology:\n\nCalculate the direct distance between the source location and each suburb in the reference list.\nImpute the reference distance of the suburb that is ‚Äòclosest‚Äô (minimal direct distance) to the source location.\n\nThe computational cost of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the length of the reference list. Since we are running our compute on browser-side this can be a tricky tradeoff.\n\n\n\nThe problem with Method 2 is we are not considering direction. Suppose we find that postcode C is the closest match to our source location. If the centroid of postcode C is farther away than the source location from the destination location, we will be over-estimating the road distance. This logic can be applied for the case of under-estimation as well. An adjusted methodology may be:\n\nCalculate the direct distance between the source location and each suburb \\(D_{gc}^k\\) for suburb \\(k\\) .\nIf we let the reference distance from suburb \\(k\\) be \\(D_{ref}^k\\), then we would like to find \\(D = \\min (D_{gc}^k+D_{ref}^k)\\) 1.\n\nThis essentially finds the most direct path between the source and destination locations given a set of waypoints that allow us to transition into using road distances rather than direct distances."
  },
  {
    "objectID": "fuel_calc_app.html",
    "href": "fuel_calc_app.html",
    "title": "üß™ Fuel Calculator App",
    "section": "",
    "text": "Demo App\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 1000\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\n\n# dist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\ndist_heuristics = pd.read_csv(open_url('https://raw.githubusercontent.com/bbpi2/bsf-leaders-retreat-2025/refs/heads/main/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\ndef dist_to_str(dist):\n  return str(round(dist, 2)) + \" km\"\n\ndef cost_to_str(cost):\n  return \"$\" + str(round(cost,2))\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Melbourne Central Station\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),\n    ),  \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n      ui.input_numeric(\"length\", \"How long is your drive in km (one way)?\", 0),\n      ui.input_slider(\"n_pax_d\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True),\n      ui.input_task_button(\"search_d\", \"Search\"),\n      ui.output_table(\"table_output_d\")\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      # pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = dist_to_str(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = dist_to_str(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = cost_to_str(cost_ppax) #\"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance (one way)\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance (one way)\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    @output\n    @render.table\n    @reactive.event(input.search_d)\n    def table_output_d():\n      n_pax = input.n_pax()\n      length = input.length()\n      cost_ppax = length * 0.1*2.5/n_pax\n\n      output = []\n      output.append({\"Item\": \"Distance (one way)\", \"Value\": dist_to_str(length)})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_to_str(cost_ppax)})\n      return pd.DataFrame(output)\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  }
]